//#include<iostream>
//using namespace std;
///*
//	2016-03-16
//	virtual class 예제
//
//	파생클래스에서 재정의한 맴버 함수를 기본 클래스의 포인터로 호출하면
//	일반적으로 재정의 전의 맴버 함수가 호출된다.
//		- C++ 컴파일러는 포인터를 이용한 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로
//		판단한다.(실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.)
//
//	재정의한 후의 맴버 함수가 호출되도록 하기 위해서는
//	기본 클래스에서 그 함수를 가상함수로 만든다
//	그러면 포인터의 자료형이 아닌 실제 가리키는 객체의 자료형을 기준으로 맴버함수를 호출하게 된다.
//	- 가상함수가 선언되고 나면, 이 함수를 오버라이딩 하는 함수도 가상함수가 된다.
//	- 파생 클래스의 함수가 굳이 virtual 선언을 추가하지 않아도 가상함수가 된다.
//	- C++의 개념이 아닌 객체지향의 개념이다.
//
//	그러므로 상속할 가능성이 있는 클래스의 소멸자는 가상 함수로 만드는 것이 ㅇ좋다
//	- 가상함수와 마찬가지도 소멸자도 상속의 계층구조상 맨 위에 존재하는 부모 클래스의
//	소멸자만 virtual로 선언하면, 이를 상속하는 파생클래스의 소멸자들도 가상 소멸자로 선언이 된다.
//
//	가상 함수를 파생 클래스에서 재정의하는 것을 오버라이딩 이라고 한다.
//
//	* 컴파일 결과가 ERROR가 없어됴 실제 실행결과에서는 ERROR를 출력할 수도 있다.
//	  이는 컴파일러 판단하기 나름이므로 컴파일러 결과를 100% 맹신해서는 안된다.
//	  ex) a.cpp와 b.cpp에서 같은 클래스명, 같은 함수로 이 중하 나는 가상함수로 정의
//		-> 컴파일 결과 : Error를 출력할수도 , 안할수도 있다
//		-> 실행결과 : error (가상 함수인지 일반 함수인지 판단할 수 없다.)
//*/
//
//class Food
//{
//public:
//	virtual void print(int n)
//	{
//		cout << "print : " << n << endl;
//	}
//};
//
//class Friut : public Food
//{
//public:
//	// 가상함수 : 오버라이딩 된 함수도 가상함수가 된다.
//	void print(int n)
//	{
//		Food::print(n * 100);
//	}
//};
//
//int main()
//{
//	// 부모클래스 형식의 포인터 선언
//	Food * food;
//	Friut fruit;
//
//	// 이런식으로 선언하게 되면 부모클래스의 print()가 아닌 
//	// 자식클래스의 print()가 호출된다. 
//	food = &fruit;
//	food->print(100);
//
//	return 0;
//}